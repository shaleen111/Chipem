#include "chip8.h"

const uint16_t START_ADDRESS = 0x200; // Space in memory before 0x200 (512) was reserved for implementation of chip8 interpreter and font and other shit
const uint16_t FONT_ADDRESS = 0x50; // Fonts start from memory address 0x50 (80)

uint8_t fontset[FONTSET_SIZE] =
{
	0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
	0x20, 0x60, 0x20, 0x20, 0x70, // 1
	0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
	0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
	0x90, 0x90, 0xF0, 0x10, 0x10, // 4
	0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
	0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
	0xF0, 0x10, 0x20, 0x40, 0x40, // 7
	0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
	0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
	0xF0, 0x90, 0xF0, 0x90, 0x90, // A
	0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
	0xF0, 0x80, 0x80, 0x80, 0xF0, // C
	0xE0, 0x90, 0x90, 0x90, 0xE0, // D
	0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
	0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};

chip8* createChip8()
{
	chip8* t = calloc(1, sizeof(chip8));
	if (t)
	{
		t->pc = START_ADDRESS; // Start reading from START_ADDRESS, the place in memory where the ROM is stored
		
		// Put the Font Data in memory, as roms expect them to be there
		for (int i = 0; i < FONTSET_SIZE; i++)
		{
			t->memory[FONT_ADDRESS + i] = fontset[i];
		}

		// Initialize the seed for random number generator that may be used by ROM
		srand(time(NULL));

		// Table to map the most significant nibble of instruction
		t->opCodes[0x0] = &Table0;
		t->opCodes[0x1] = &O1nnn;
		t->opCodes[0x2] = &O2nnn;
		t->opCodes[0x3] = &O3xkk;
		t->opCodes[0x4] = &O4xkk;
		t->opCodes[0x5] = &O5xy0;
		t->opCodes[0x6] = &O6xkk;
		t->opCodes[0x7] = &O7xkk;
		t->opCodes[0x8] = &Table8;
		t->opCodes[0x9] = &O9xy0;
		t->opCodes[0xA] = &OAnnn;
		t->opCodes[0xB] = &OBnnn;
		t->opCodes[0xC] = &OCxkk;
		t->opCodes[0xD] = &ODxyn;
		t->opCodes[0xE] = &TableE;
		t->opCodes[0xF] = &TableF;


		
		t->table0[0x0] = &O00E0;
		t->table0[0xE] = &O00EE;

		t->table8[0x0] = &O8xy0;
		t->table8[0x1] = &O8xy1;
		t->table8[0x2] = &O8xy2;
		t->table8[0x3] = &O8xy3;
		t->table8[0x4] = &O8xy4;
		t->table8[0x5] = &O8xy5;
		t->table8[0x6] = &O8xy6;
		t->table8[0x7] = &O8xy7;
		t->table8[0xE] = &O8xyE;

		t->tableE[0x1] = &OExA1;
		t->tableE[0xE] = &OEx9E;

		t->tableF[0x7] = &OFx07;
		t->tableF[0xA] = &OFx0A;
		t->tableF[0x15] = &OFx15;
		t->tableF[0x18] = &OFx18;
		t->tableF[0x1E] = &OFx1E;
		t->tableF[0x29] = &OFx29;
		t->tableF[0x33] = &OFx33;
		t->tableF[0x55] = &OFx55;
		t->tableF[0x65] = &OFx65;

		t->drawFlag = false;
	}
	else
	{
		printf("Error: Failed to calloc chip8");
		return NULL;
	}
	return t;
}

void destroyChip8(chip8* t)
{
	free(t);
}

int loadROM(chip8* t, const char* filename)
{
	FILE* file = fopen(filename, "rb");
	if (file)
	{
		// Find file size and make buffer of equal size
		fseek(file, 0, SEEK_END);
		long int size = ftell(file);
		char *buffer = malloc(size);

		if (buffer)
		{
			// Go back to beginning and then copy contents of the ROM
			// to the memory
			fseek(file, 0, SEEK_SET);
			fread(buffer, size, 1, file);
			fclose(file);
			printf("ROM: %d", buffer[0]);
			for (int i = 0; i < size; i++)
			{
				t->memory[START_ADDRESS + i] = buffer[i];
			}
			free(buffer);

			return 0;
		}
	}

	printf("Error: ROM Could not Be Loaded");

	return 1;
}

int getRandomNumber(int lower, int upper)
{
	return (rand() % (upper - lower + 1) + lower);

}

void Table0(chip8* t)
{
	(*(t->table0[t->opCode & 0xF])) (t);
}

void Table8(chip8 *t)
{
	(*(t->table8[t->opCode & 0xF])) (t);
}

void TableE(chip8 *t)
{
	(*(t->tableE[t->opCode & 0xF])) (t);
}

void TableF(chip8 *t)
{
	(*(t->tableF[t->opCode & 0xFF])) (t);

}

void cycleCPU(chip8 *t) 
{ 
	// Fetch and Decode Opcode
	// Each opcode is 2 bytes
	t->opCode = (t->memory[t->pc] << 8) | (t->memory[t->pc + 1]);

	// Increase PC
	t->pc += 2;

	// Execute Op Code
	(*(t->opCodes[(t->opCode & 0xF000) >> 12])) (t);
}

void updateTimers(chip8* t)
{
	if (t->delayTimer > 0)
	{
		t->delayTimer--;
	}

	if (t->soundTimer > 0)
	{
		t->soundTimer--;
	}
}

// Get a random byte
// If implemented in hardware would likely just use static noise
// generated by hardware 
// But in software gotta use pseudo-random function rand
uint8_t randomByte()
{
	return (uint8_t)getRandomNumber(0, 255);
}

// INSTRUCTIONS/OPCODE Implementation

// CLS
// Just set video buffer to 0
void O00E0(chip8 *t)
{
	memset(t->display, 0, sizeof(t->display));
	t->drawFlag = true;
}

// RET
// Decrement the stack pointer
// Get the pc value
void O00EE(chip8 *t)
{
	t->sp--;
	t->pc = t->stack[t->sp];
}

// JP
// JP does not remember from where it was executed
// No need for keeping track of pc in stack
void O1nnn(chip8 *t)
{
	uint16_t addr = t->opCode & 0x0FFF;
	t->pc = addr;
}

// CALL addr
// Need to keep track of program counter from where CALL was called
// So need interaction with stack
void O2nnn(chip8 *t)
{
	uint16_t addr = t->opCode & 0x0FFF;
	t->stack[t->sp] = t->pc;
	t->sp++;
	t->pc = addr;
}

// 3xkk - SE Vx, byte
// Skip next instruction if Vx = kk
void O3xkk(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t kk = t->opCode & 0x00FF;

	if (t->registers[Vx] == kk)
	{
		t->pc += 2;
	}
}

// 4xkk - SNE Vx, byte
// Skip next instruction if Vx != kk
void O4xkk(chip8 *t) 
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t kk = t->opCode & 0x00FF;

	if (t->registers[Vx] != kk)
	{
		t->pc += 2;
	}
}

// 5xy0 - SE Vx, Vy
// Skip next instruction if Vx = Vy.
void O5xy0(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	if (t->registers[Vx] == t->registers[Vy])
	{
		t->pc += 2;
	}
}

// 6xkk - LD Vx, byte
// Set Vx = kk
void O6xkk(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t kk = t->opCode & 0x00FF;

	t->registers[Vx] = kk;
}

// 7xkk - ADD Vx, byte
// Set Vx = Vx + kk
void O7xkk(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t kk = t->opCode & 0x00FF;

	t->registers[Vx] += kk;
}

// 8xy0 - LD Vx, Vy
// Set Vx = Vy
void O8xy0(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	t->registers[Vx] = t->registers[Vy];
}

// 8xy1 - OR Vx, Vy
// Set Vx = Vx OR Vy
void O8xy1(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	t->registers[Vx] |= t->registers[Vy];
}

// 8xy2 - AND Vx, Vy
// Set Vx = Vx AND Vy
void O8xy2(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	t->registers[Vx] &= t->registers[Vy];
}

// 8xy3 - XOR Vx, Vy
// Set Vx = Vx XOR Vy
void O8xy3(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	t->registers[Vx] ^= t->registers[Vy];
}

// 8xy4 - ADD Vx, Vy
// Set Vx = Vx + Vy, set VF = carry
void O8xy4(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> (8);
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;
	
	uint16_t sum = t->registers[Vx] + t->registers[Vy];

	t->registers[0xF] = (sum > 255) ? 1 : 0;
	
	t->registers[Vx] = sum & 0xFF;
}

// 8xy5 - SUB Vx, Vy
// Set Vx = Vx - Vy, set VF = NOT borrow
void O8xy5(chip8 *t) 
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	if (t->registers[Vx] < t->registers[Vy])
	{
		t->registers[0xF] = 0;
	}
	else
	{
		t->registers[0xF] = 1;
	}

	t->registers[Vx] -= t->registers[Vy];

}

// 8xy6 - SHR Vx
// Set Vx = Vx SHR 1
void O8xy6(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	t->registers[0xF] = (t->registers[Vx] & 0x1);

	t->registers[Vx] >>= 1;
}

// 8xy7 - SUBN Vx, Vy
// Set Vx = Vy - Vx, set VF = NOT borrow.
void O8xy7(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	if (t->registers[Vy] > t->registers[Vx])
	{
		t->registers[0xF] = 1;
	}
	else
	{
		t->registers[0xF] = 0;
	}

	t->registers[Vx] = t->registers[Vy] - t->registers[Vx];
}

// 8xyE - SHL Vx
// Set Vx = Vx SHL 1
void O8xyE(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	t->registers[0xF] = (t->registers[Vx] & 0x80) >> 7;

	t->registers[Vx] <<= 1;
}

// 9xy0 - SNE Vx, Vy
// Skip next instruction if Vx != Vy
void O9xy0(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;

	if (t->registers[Vx] != t->registers[Vy])
	{
		t->pc += 2;
	}
}

// Annn - LD I, addr
// Set I = nnn
void OAnnn(chip8 *t)
{
	uint16_t addr = t->opCode & 0x0FFF;

	t->indexRegister = addr;
}

// Bnnn - JP V0, addr
// Jump to location nnn + V0
void OBnnn(chip8 *t)
{
	uint16_t addr = t->opCode & 0x0FFF;
	addr += t->registers[0];
	t->pc = addr;
}

// Cxkk - RND Vx, byte
// Set Vx = random byte AND kk
void OCxkk(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t kk = t->opCode & 0x00FF;

	t->registers[Vx] = randomByte() & kk;
}

// Dxyn - DRW Vx, Vy, nibble
// Display n - byte sprite starting at memory location I at(Vx, Vy), set VF = collision
void ODxyn(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> (8);
	uint8_t Vy = (t->opCode & 0x00F0) >> 4;
	uint8_t height = t->opCode & 0x000F;

	uint8_t x = t->registers[Vx];
	uint8_t y = t->registers[Vy];
	
	t->registers[0xF] = 0;
	for (int i = 0; i < height; i++)
	{
		uint8_t spriteRow = t->memory[t->indexRegister + i];
		for (int j = 0; j < 8; j++)
		{
			uint8_t spritePixel = spriteRow & (0x80 >> j);
			uint32_t *screenPixel = &t->display[((i + y) * VWIDTH + j + x) % (VWIDTH * VHEIGHT)];
			
			if (spritePixel)
			{
				if (*screenPixel == 0xFFFFFFFF)
				{
					t->registers[0xF] = 1;
				}
				*screenPixel ^= 0xFFFFFFFF;
			}
		}
	}

	t->drawFlag = true;
}

// Ex9E - SKP Vx
// Skip next instruction if key with the value of Vx is pressed
void OEx9E(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t key = t->registers[Vx];

	if (t->keys[key])
	{
		t->pc += 2;
	}
}

// ExA1 - SKNP Vx
// Skip next instruction if key with the value of Vx is not pressed
void OExA1(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t key = t->registers[Vx];

	if (!t->keys[key])
	{
		t->pc += 2;
	}
}

// Fx07 - LD Vx, DT
// Set Vx = delay timer value
void OFx07(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	t->registers[Vx] = t->delayTimer;
}

// Fx0A - LD Vx, K
// Wait for a key press, store the value of the key in Vx
void OFx0A(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	bool found = false;

	for (int i = 0; i < 16; i++)
	{
		if (t->keys[i])
		{
			printf("Found");
			t->registers[Vx] = i;
			found = true;
			break;
		}
	}

	if (!found)
	{
		t->pc -= 2;
	}
}

// Fx15 - LD DT, Vx
// Set delay timer = Vx.
void OFx15(chip8 *t) 
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	t->delayTimer = t->registers[Vx];
}

// Fx18 - LD ST, Vx
// Set sound timer = Vx
void OFx18(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	t->soundTimer = t->registers[Vx];
}

// Fx1E - ADD I, Vx
// Set I = I + Vx
void OFx1E(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	t->indexRegister += t->registers[Vx];
}

// Fx29 - LD F, Vx
// Set I = location of sprite for digit Vx
void OFx29(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	t->indexRegister = FONT_ADDRESS + (5 * t->registers[Vx]);
}

// Fx33 - LD B, Vx
// Store BCD representation of Vx in memory locations I, I + 1, and I + 2.
void OFx33(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;
	uint8_t value = t->registers[Vx];

	for (int i = 2; i > -1; i--)
	{
		t->memory[t->indexRegister + i] = value % 10;
		value /= 10;
	}
}

// Fx55 - LD[I], Vx
// Store registers V0 through Vx in memory starting at location I.
void OFx55(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	for (int i = 0; i <= Vx; i++)
	{
		t->memory[t->indexRegister + i] = t->registers[i];
	}
}

// Fx65 - LD Vx
// Read registers V0 through Vx from memory starting at location I
void OFx65(chip8 *t)
{
	uint8_t Vx = (t->opCode & 0x0F00) >> 8;

	for (int i = 0; i <= Vx; i++)
	{
		t->registers[i] = t->memory[t->indexRegister + i];
	}
}